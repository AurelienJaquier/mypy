[case testLowLevelIntBasics]
from mypy_extensions import i64

def f() -> i64:
    x: i64 = 5
    y = x
    return y
[out]
def f():
    x, y :: int64
L0:
    x = 5
    y = x
    return y

[case testLowLevelIntCompare]
from mypy_extensions import i64

def min(x: i64, y: i64) -> i64:
    if x < y:
        return x
    else:
        return y
[out]
def min(x, y):
    x, y :: int64
    r0 :: bit
L0:
    r0 = x < y :: signed
    if r0 goto L1 else goto L2 :: bool
L1:
    return x
L2:
    return y
L3:
    unreachable

[case testLowLevelIntArithmetic]
from mypy_extensions import i64

def f(x: i64, y: i64) -> i64:
    z = x + y
    return y - z
[out]
def f(x, y):
    x, y, r0, z, r1 :: int64
L0:
    r0 = x + y
    z = r0
    r1 = y - z
    return r1

[case testLowLevelIntNegation]
from mypy_extensions import i64

def f() -> i64:
    i: i64 = -3
    return -i
[out]
def f():
    i, r0 :: int64
L0:
    i = -3
    r0 = 0 - i
    return r0

[case testLowLevelIntBoxingAndUnboxing]
from typing import Any
from mypy_extensions import i64

def f(a: Any) -> None:
    b: i64 = a
    a = b
[out]
def f(a):
    a :: object
    r0, b :: int64
    r1 :: object
L0:
    r0 = unbox(int64, a)
    b = r0
    r1 = box(int64, b)
    a = r1
    return 1

[case testLowLevelIntListGetItem]
from typing import List
from mypy_extensions import i64

def f(a: List[i64], i: i64) -> i64:
    return a[i]
[out]
def f(a, i):
    a :: list
    i :: int64
    r0 :: object
    r1 :: int64
L0:
    r0 = CPyList_GetItemInt64(a, i)
    r1 = unbox(int64, r0)
    return r1

[case testLowLevelIntMixedArithmetic]
from mypy_extensions import i64

def f() -> i64:
    a: i64 = 1
    b = a + 2
    return 3 - b
[out]
def f():
    a, r0, b, r1 :: int64
L0:
    a = 1
    r0 = a + 2
    b = r0
    r1 = 3 - b
    return r1

[case testLowLevelIntMixedComparison]
from mypy_extensions import i64

def f(a: i64) -> i64:
    if a < 3:
        return 1
    elif 3 < a:
        return 2
    return 3
[out]
def f(a):
    a :: int64
    r0, r1 :: bit
L0:
    r0 = a < 3 :: signed
    if r0 goto L1 else goto L2 :: bool
L1:
    return 1
L2:
    r1 = 3 < a :: signed
    if r1 goto L3 else goto L4 :: bool
L3:
    return 2
L4:
L5:
    return 3

[case testLowLevelIntInplaceAdd]
from mypy_extensions import i64

def f(a: i64) -> i64:
    b = a
    b += 1
    a += b
    return a
[out]
def f(a):
    a, b, r0, r1 :: int64
L0:
    b = a
    r0 = b + 1
    b = r0
    r1 = a + b
    a = r1
    return a

[case testLowLevelIntBitwiseOps]
from mypy_extensions import i64

def forward(a: i64, b: i64) -> i64:
    b = a & 1
    a = b | 2
    b = a ^ 3
    a = b << 4
    b = a >> 5
    return b

def reverse(a: i64, b: i64) -> i64:
    b = 1 & a
    a = 2 | b
    b = 3 ^ a
    a = 4 << b
    b = 5 >> a
    return b

def unary(a: i64) -> i64:
    return ~a
[out]
def forward(a, b):
    a, b, r0, r1, r2, r3, r4 :: int64
L0:
    r0 = a & 1
    b = r0
    r1 = b | 2
    a = r1
    r2 = a ^ 3
    b = r2
    r3 = b << 4
    a = r3
    r4 = a >> 5
    b = r4
    return b
def reverse(a, b):
    a, b, r0, r1, r2, r3, r4 :: int64
L0:
    r0 = 1 & a
    b = r0
    r1 = 2 | b
    a = r1
    r2 = 3 ^ a
    b = r2
    r3 = 4 << b
    a = r3
    r4 = 5 >> a
    b = r4
    return b
def unary(a):
    a, r0 :: int64
L0:
    r0 = a ^ -1
    return r0
