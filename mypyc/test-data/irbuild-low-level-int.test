[case testLowLevelIntBasics]
from mypy_extensions import i64

def f() -> i64:
    x: i64 = 5
    y = x
    return y
[out]
def f():
    x, y :: int64
L0:
    x = 5
    y = x
    return y

[case testLowLevelIntCompare]
from mypy_extensions import i64

def min(x: i64, y: i64) -> i64:
    if x < y:
        return x
    else:
        return y

def all_comparisons(x: i64) -> int:
    if x == 2:
        y = 10
    elif 3 != x:
        y = 11
    elif x > 4:
        y = 12
    elif 6 >= x:
        y = 13
    elif x < 5:
        y = 14
    elif 6 <= x:
        y = 15
    else:
        y = 16
    return y
[out]
def min(x, y):
    x, y :: int64
    r0 :: bit
L0:
    r0 = x < y :: signed
    if r0 goto L1 else goto L2 :: bool
L1:
    return x
L2:
    return y
L3:
    unreachable
def all_comparisons(x):
    x :: int64
    r0 :: bit
    y :: int
    r1, r2, r3, r4, r5 :: bit
L0:
    r0 = x == 2
    if r0 goto L1 else goto L2 :: bool
L1:
    y = 20
    goto L18
L2:
    r1 = 3 != x
    if r1 goto L3 else goto L4 :: bool
L3:
    y = 22
    goto L17
L4:
    r2 = x > 4 :: signed
    if r2 goto L5 else goto L6 :: bool
L5:
    y = 24
    goto L16
L6:
    r3 = 6 >= x :: signed
    if r3 goto L7 else goto L8 :: bool
L7:
    y = 26
    goto L15
L8:
    r4 = x < 5 :: signed
    if r4 goto L9 else goto L10 :: bool
L9:
    y = 28
    goto L14
L10:
    r5 = 6 <= x :: signed
    if r5 goto L11 else goto L12 :: bool
L11:
    y = 30
    goto L13
L12:
    y = 32
L13:
L14:
L15:
L16:
L17:
L18:
    return y

[case testLowLevelIntArithmetic]
from mypy_extensions import i64

def f(x: i64, y: i64) -> i64:
    z = x + y
    return y - z
[out]
def f(x, y):
    x, y, r0, z, r1 :: int64
L0:
    r0 = x + y
    z = r0
    r1 = y - z
    return r1

[case testLowLevelIntNegation]
from mypy_extensions import i64

def f() -> i64:
    i: i64 = -3
    return -i
[out]
def f():
    i, r0 :: int64
L0:
    i = -3
    r0 = 0 - i
    return r0

[case testLowLevelIntBoxingAndUnboxing]
from typing import Any
from mypy_extensions import i64

def f(a: Any) -> None:
    b: i64 = a
    a = b
[out]
def f(a):
    a :: object
    r0, b :: int64
    r1 :: object
L0:
    r0 = unbox(int64, a)
    b = r0
    r1 = box(int64, b)
    a = r1
    return 1

[case testLowLevelIntListGetSetItem]
from typing import List
from mypy_extensions import i64

def get(a: List[i64], i: i64) -> i64:
    return a[i]
def set(a: List[i64], i: i64, x: i64) -> None:
    a[i] = x
[out]
def get(a, i):
    a :: list
    i :: int64
    r0 :: object
    r1 :: int64
L0:
    r0 = CPyList_GetItemInt64(a, i)
    r1 = unbox(int64, r0)
    return r1
def set(a, i, x):
    a :: list
    i, x :: int64
    r0 :: object
    r1 :: bit
L0:
    r0 = box(int64, x)
    r1 = CPyList_SetItemInt64(a, i, r0)
    return 1

[case testLowLevelIntMixedArithmetic]
from mypy_extensions import i64

def f() -> i64:
    a: i64 = 1
    b = a + 2
    return 3 - b
[out]
def f():
    a, r0, b, r1 :: int64
L0:
    a = 1
    r0 = a + 2
    b = r0
    r1 = 3 - b
    return r1

[case testLowLevelIntMixedComparison]
from mypy_extensions import i64

def f(a: i64) -> i64:
    if a < 3:
        return 1
    elif 3 < a:
        return 2
    return 3
[out]
def f(a):
    a :: int64
    r0, r1 :: bit
L0:
    r0 = a < 3 :: signed
    if r0 goto L1 else goto L2 :: bool
L1:
    return 1
L2:
    r1 = 3 < a :: signed
    if r1 goto L3 else goto L4 :: bool
L3:
    return 2
L4:
L5:
    return 3

[case testLowLevelIntInplaceOperations]
from mypy_extensions import i64

def add(a: i64) -> i64:
    b = a
    b += 1
    a += b
    return a
def others(a: i64, b: i64) -> i64:
    a -= b
    a *= b
    a &= b
    a |= b
    a ^= b
    a <<= b
    a >>= b
    return a
[out]
def add(a):
    a, b, r0, r1 :: int64
L0:
    b = a
    r0 = b + 1
    b = r0
    r1 = a + b
    a = r1
    return a
def others(a, b):
    a, b, r0, r1, r2, r3, r4, r5, r6 :: int64
L0:
    r0 = a - b
    a = r0
    r1 = a * b
    a = r1
    r2 = a & b
    a = r2
    r3 = a | b
    a = r3
    r4 = a ^ b
    a = r4
    r5 = a << b
    a = r5
    r6 = a >> b
    a = r6
    return a

[case testLowLevelIntBitwiseOps]
from mypy_extensions import i64

def forward(a: i64, b: i64) -> i64:
    b = a & 1
    a = b | 2
    b = a ^ 3
    a = b << 4
    b = a >> 5
    return b

def reverse(a: i64, b: i64) -> i64:
    b = 1 & a
    a = 2 | b
    b = 3 ^ a
    a = 4 << b
    b = 5 >> a
    return b

def unary(a: i64) -> i64:
    return ~a
[out]
def forward(a, b):
    a, b, r0, r1, r2, r3, r4 :: int64
L0:
    r0 = a & 1
    b = r0
    r1 = b | 2
    a = r1
    r2 = a ^ 3
    b = r2
    r3 = b << 4
    a = r3
    r4 = a >> 5
    b = r4
    return b
def reverse(a, b):
    a, b, r0, r1, r2, r3, r4 :: int64
L0:
    r0 = 1 & a
    b = r0
    r1 = 2 | b
    a = r1
    r2 = 3 ^ a
    b = r2
    r3 = 4 << b
    a = r3
    r4 = 5 >> a
    b = r4
    return b
def unary(a):
    a, r0 :: int64
L0:
    r0 = a ^ -1
    return r0

[case testLowLevelIntDivision]
from mypy_extensions import i64

def constant_divisor(x: i64) -> i64:
    return x // 7
def variable_divisor(x: i64, y: i64) -> i64:
    return x // y
def constant_lhs(x: i64) -> i64:
    return 27 // x
def divide_by_neg_one(x: i64) -> i64:
    return x // -1
def divide_by_zero(x: i64) -> i64:
    return x // 0
[out]
def constant_divisor(x):
    x, r0, r1 :: int64
    r2, r3, r4 :: bit
    r5 :: int64
    r6 :: bit
    r7 :: int64
L0:
    r0 = x / 7
    r1 = r0
    r2 = x < 0 :: signed
    r3 = 7 < 0 :: signed
    r4 = r2 == r3
    if r4 goto L3 else goto L1 :: bool
L1:
    r5 = r1 * 7
    r6 = r5 == x
    if r6 goto L3 else goto L2 :: bool
L2:
    r7 = r1 - 1
    r1 = r7
L3:
    return r1
def variable_divisor(x, y):
    x, y, r0 :: int64
L0:
    r0 = CPyInt64_Divide(x, y)
    return r0
def constant_lhs(x):
    x, r0 :: int64
L0:
    r0 = CPyInt64_Divide(27, x)
    return r0
def divide_by_neg_one(x):
    x, r0 :: int64
L0:
    r0 = CPyInt64_Divide(x, -1)
    return r0
def divide_by_zero(x):
    x, r0 :: int64
L0:
    r0 = CPyInt64_Divide(x, 0)
    return r0

[case testLowLevelIntMod]
from mypy_extensions import i64

def constant_divisor(x: i64) -> i64:
    return x % 7
def variable_divisor(x: i64, y: i64) -> i64:
    return x % y
def constant_lhs(x: i64) -> i64:
    return 27 % x
def mod_by_zero(x: i64) -> i64:
    return x % 0
[out]
def constant_divisor(x):
    x, r0, r1 :: int64
    r2, r3, r4, r5 :: bit
    r6 :: int64
L0:
    r0 = x % 7
    r1 = r0
    r2 = x < 0 :: signed
    r3 = 7 < 0 :: signed
    r4 = r2 == r3
    if r4 goto L3 else goto L1 :: bool
L1:
    r5 = r1 == 0
    if r5 goto L3 else goto L2 :: bool
L2:
    r6 = r1 + 7
    r1 = r6
L3:
    return r1
def variable_divisor(x, y):
    x, y, r0 :: int64
L0:
    r0 = CPyInt64_Remainder(x, y)
    return r0
def constant_lhs(x):
    x, r0 :: int64
L0:
    r0 = CPyInt64_Remainder(27, x)
    return r0
def mod_by_zero(x):
    x, r0 :: int64
L0:
    r0 = CPyInt64_Remainder(x, 0)
    return r0

[case testLowLevelIntInPlaceDiv]
from mypy_extensions import i64

def by_constant(x: i64) -> i64:
    x //= 7
    return x
def by_variable(x: i64, y: i64) -> i64:
    x //= y
    return x
[out]
def by_constant(x):
    x, r0, r1 :: int64
    r2, r3, r4 :: bit
    r5 :: int64
    r6 :: bit
    r7 :: int64
L0:
    r0 = x / 7
    r1 = r0
    r2 = x < 0 :: signed
    r3 = 7 < 0 :: signed
    r4 = r2 == r3
    if r4 goto L3 else goto L1 :: bool
L1:
    r5 = r1 * 7
    r6 = r5 == x
    if r6 goto L3 else goto L2 :: bool
L2:
    r7 = r1 - 1
    r1 = r7
L3:
    x = r1
    return x
def by_variable(x, y):
    x, y, r0 :: int64
L0:
    r0 = CPyInt64_Divide(x, y)
    x = r0
    return x

[case testLowLevelIntInPlaceMod]
from mypy_extensions import i64

def by_constant(x: i64) -> i64:
    x %= 7
    return x
def by_variable(x: i64, y: i64) -> i64:
    x %= y
    return x
[out]
def by_constant(x):
    x, r0, r1 :: int64
    r2, r3, r4, r5 :: bit
    r6 :: int64
L0:
    r0 = x % 7
    r1 = r0
    r2 = x < 0 :: signed
    r3 = 7 < 0 :: signed
    r4 = r2 == r3
    if r4 goto L3 else goto L1 :: bool
L1:
    r5 = r1 == 0
    if r5 goto L3 else goto L2 :: bool
L2:
    r6 = r1 + 7
    r1 = r6
L3:
    x = r1
    return x
def by_variable(x, y):
    x, y, r0 :: int64
L0:
    r0 = CPyInt64_Remainder(x, y)
    x = r0
    return x

[case testLowLevelIntI32BinaryOp]
from mypy_extensions import i32

def add_op(x: i32, y: i32) -> i32:
    x = y + x
    y = x + 5
    y += x
    y += 7
    x = 5 + y
    return x
def compare(x: i32, y: i32) -> None:
    a = x == y
    b = x == -5
    c = x < y
    d = x < -5
    e = -5 == x
    f = -5 < x
[out]
def add_op(x, y):
    x, y, r0, r1, r2, r3, r4 :: int32
L0:
    r0 = y + x
    x = r0
    r1 = x + 5
    y = r1
    r2 = y + x
    y = r2
    r3 = y + 7
    y = r3
    r4 = 5 + y
    x = r4
    return x
def compare(x, y):
    x, y :: int32
    r0 :: bit
    a :: bool
    r1 :: bit
    b :: bool
    r2 :: bit
    c :: bool
    r3 :: bit
    d :: bool
    r4 :: bit
    e :: bool
    r5 :: bit
    f :: bool
L0:
    r0 = x == y
    a = r0
    r1 = x == -5
    b = r1
    r2 = x < y :: signed
    c = r2
    r3 = x < -5 :: signed
    d = r3
    r4 = -5 == x
    e = r4
    r5 = -5 < x :: signed
    f = r5
    return 1

[case testLowLevelIntI32UnaryOp]
from mypy_extensions import i32

def unary(x: i32) -> i32:
    y = -x
    x = ~y
    y = +x
    return y
[out]
def unary(x):
    x, r0, y, r1 :: int32
L0:
    r0 = 0 - x
    y = r0
    r1 = y ^ -1
    x = r1
    y = x
    return y

[case testLowLevelIntI32DivisionByConstant]
from mypy_extensions import i32

def div_by_constant(x: i32) -> i32:
    x = x // 5
    x //= 17
    return x
[out]
def div_by_constant(x):
    x, r0, r1 :: int32
    r2, r3, r4 :: bit
    r5 :: int32
    r6 :: bit
    r7, r8, r9 :: int32
    r10, r11, r12 :: bit
    r13 :: int32
    r14 :: bit
    r15 :: int32
L0:
    r0 = x / 5
    r1 = r0
    r2 = x < 0 :: signed
    r3 = 5 < 0 :: signed
    r4 = r2 == r3
    if r4 goto L3 else goto L1 :: bool
L1:
    r5 = r1 * 5
    r6 = r5 == x
    if r6 goto L3 else goto L2 :: bool
L2:
    r7 = r1 - 1
    r1 = r7
L3:
    x = r1
    r8 = x / 17
    r9 = r8
    r10 = x < 0 :: signed
    r11 = 17 < 0 :: signed
    r12 = r10 == r11
    if r12 goto L6 else goto L4 :: bool
L4:
    r13 = r9 * 17
    r14 = r13 == x
    if r14 goto L6 else goto L5 :: bool
L5:
    r15 = r9 - 1
    r9 = r15
L6:
    x = r9
    return x

[case testLowLevelIntI32ModByConstant]
from mypy_extensions import i32

def mod_by_constant(x: i32) -> i32:
    x = x % 5
    x %= 17
    return x
[out]
def mod_by_constant(x):
    x, r0, r1 :: int32
    r2, r3, r4, r5 :: bit
    r6, r7, r8 :: int32
    r9, r10, r11, r12 :: bit
    r13 :: int32
L0:
    r0 = x % 5
    r1 = r0
    r2 = x < 0 :: signed
    r3 = 5 < 0 :: signed
    r4 = r2 == r3
    if r4 goto L3 else goto L1 :: bool
L1:
    r5 = r1 == 0
    if r5 goto L3 else goto L2 :: bool
L2:
    r6 = r1 + 5
    r1 = r6
L3:
    x = r1
    r7 = x % 17
    r8 = r7
    r9 = x < 0 :: signed
    r10 = 17 < 0 :: signed
    r11 = r9 == r10
    if r11 goto L6 else goto L4 :: bool
L4:
    r12 = r8 == 0
    if r12 goto L6 else goto L5 :: bool
L5:
    r13 = r8 + 17
    r8 = r13
L6:
    x = r8
    return x

[case testLowLevelIntI32DivModByVariable]
from mypy_extensions import i32

def divmod(x: i32, y: i32) -> i32:
    a = x // y
    return a % y
[out]
def divmod(x, y):
    x, y, r0, a, r1 :: int32
L0:
    r0 = CPyInt32_Divide(x, y)
    a = r0
    r1 = CPyInt32_Remainder(a, y)
    return r1

[case testLowLevelIntI32BoxAndUnbox]
from typing import Any
from mypy_extensions import i32

def f(x: Any) -> Any:
    y: i32 = x
    return y
[out]
def f(x):
    x :: object
    r0, y :: int32
    r1 :: object
L0:
    r0 = unbox(int32, x)
    y = r0
    r1 = box(int32, y)
    return r1

[case testLowLevelIntForRange]
from mypy_extensions import i64

def g(a: i64) -> None: pass

def f(x: i64) -> None:
    n: i64  # TODO: Infer the type
    for n in range(x):
        g(n)
[out]
def g(a):
    a :: int64
L0:
    return 1
def f(x):
    x, r0, n :: int64
    r1 :: bit
    r2 :: None
    r3 :: int64
L0:
    r0 = 0
    n = r0
L1:
    r1 = r0 < x :: signed
    if r1 goto L2 else goto L4 :: bool
L2:
    r2 = g(n)
L3:
    r3 = r0 + 1
    r0 = r3
    n = r3
    goto L1
L4:
    return 1

[case testLowLevelIntConvertIntToI64_64bit]
from mypy_extensions import i64

def int_to_i64(a: int) -> i64:
    return a
[out]
def int_to_i64(a):
    a :: int
    r0 :: native_int
    r1 :: bit
    r2, r3 :: int64
    r4 :: ptr
    r5 :: c_ptr
    r6 :: int64
L0:
    r0 = a & 1
    r1 = r0 == 0
    if r1 goto L1 else goto L2 :: bool
L1:
    r2 = a >> 1
    r3 = r2
    goto L3
L2:
    r4 = a ^ 1
    r5 = r4
    r6 = CPyLong_AsInt64(r5)
    r3 = r6
    keep_alive a
L3:
    return r3

[case testLowLevelIntConvertI64ToInt_64bit]
from mypy_extensions import i64

def i64_to_int(a: i64) -> int:
    return a
[out]
def i64_to_int(a):
    a :: int64
    r0, r1 :: bit
    r2, r3, r4 :: int
L0:
    r0 = a < 4611686018427387904 :: unsigned
    if r0 goto L3 else goto L1 :: bool
L1:
    r1 = a >= -4611686018427387904 :: signed
    if r1 goto L3 else goto L2 :: bool
L2:
    r2 = CPyTagged_FromSsize_t(a)
    r3 = r2
    goto L4
L3:
    r4 = a << 1
    r3 = r4
L4:
    return r3

[case testLowLevelIntTuple]
from typing import Tuple
from mypy_extensions import i64

def f(x: i64, y: i64) -> Tuple[i64, i64]:
    return x, y

def g() -> Tuple[i64, i64]:
    # TODO: Avoid boxing and unboxing
    return 1, 2

def h() -> i64:
    x, y = g()
    t = g()
    return x + y + t[0]
[out]
def f(x, y):
    x, y :: int64
    r0 :: tuple[int64, int64]
L0:
    r0 = (x, y)
    return r0
def g():
    r0 :: tuple[int, int]
    r1 :: object
    r2 :: tuple[int64, int64]
L0:
    r0 = (2, 4)
    r1 = box(tuple[int, int], r0)
    r2 = unbox(tuple[int64, int64], r1)
    return r2
def h():
    r0 :: tuple[int64, int64]
    r1, x, r2, y :: int64
    r3, t :: tuple[int64, int64]
    r4, r5, r6 :: int64
L0:
    r0 = g()
    r1 = r0[0]
    x = r1
    r2 = r0[1]
    y = r2
    r3 = g()
    t = r3
    r4 = x + y
    r5 = t[0]
    r6 = r4 + r5
    return r6

[case testLowLevelIntMixWithTagged1]
from mypy_extensions import i64
def f(x: i64, y: int) -> i64:
    return x + y
[out]
def f(x, y):
    x :: int64
    y :: int
    r0 :: native_int
    r1 :: bit
    r2, r3 :: int64
    r4 :: ptr
    r5 :: c_ptr
    r6, r7 :: int64
L0:
    r0 = y & 1
    r1 = r0 == 0
    if r1 goto L1 else goto L2 :: bool
L1:
    r2 = y >> 1
    r3 = r2
    goto L3
L2:
    r4 = y ^ 1
    r5 = r4
    r6 = CPyLong_AsInt64(r5)
    r3 = r6
    keep_alive y
L3:
    r7 = x + r3
    return r7

[case testLowLevelIntMixWithTagged2]
from mypy_extensions import i64
def f(x: int, y: i64) -> i64:
    return x + y
[out]
def f(x, y):
    x :: int
    y :: int64
    r0 :: native_int
    r1 :: bit
    r2, r3 :: int64
    r4 :: ptr
    r5 :: c_ptr
    r6, r7 :: int64
L0:
    r0 = x & 1
    r1 = r0 == 0
    if r1 goto L1 else goto L2 :: bool
L1:
    r2 = x >> 1
    r3 = r2
    goto L3
L2:
    r4 = x ^ 1
    r5 = r4
    r6 = CPyLong_AsInt64(r5)
    r3 = r6
    keep_alive x
L3:
    r7 = r3 + y
    return r7

[case testLowLevelIntMixWithTaggedInPlace1]
from mypy_extensions import i64
def f(y: i64) -> int:
    x = 0
    x += y
    return x
[out]
def f(y):
    y :: int64
    x :: int
    r0 :: native_int
    r1 :: bit
    r2, r3 :: int64
    r4 :: ptr
    r5 :: c_ptr
    r6, r7 :: int64
    r8, r9 :: bit
    r10, r11, r12 :: int
L0:
    x = 0
    r0 = x & 1
    r1 = r0 == 0
    if r1 goto L1 else goto L2 :: bool
L1:
    r2 = x >> 1
    r3 = r2
    goto L3
L2:
    r4 = x ^ 1
    r5 = r4
    r6 = CPyLong_AsInt64(r5)
    r3 = r6
    keep_alive x
L3:
    r7 = r3 + y
    r8 = r7 < 4611686018427387904 :: unsigned
    if r8 goto L6 else goto L4 :: bool
L4:
    r9 = r7 >= -4611686018427387904 :: signed
    if r9 goto L6 else goto L5 :: bool
L5:
    r10 = CPyTagged_FromSsize_t(r7)
    r11 = r10
    goto L7
L6:
    r12 = r7 << 1
    r11 = r12
L7:
    x = r11
    return x

[case testLowLevelIntMixWithTaggedInPlace2]
from mypy_extensions import i64
def f(y: int) -> i64:
    x: i64 = 0
    x += y
    return x
[out]
def f(y):
    y :: int
    x :: int64
    r0 :: native_int
    r1 :: bit
    r2, r3 :: int64
    r4 :: ptr
    r5 :: c_ptr
    r6, r7 :: int64
L0:
    x = 0
    r0 = y & 1
    r1 = r0 == 0
    if r1 goto L1 else goto L2 :: bool
L1:
    r2 = y >> 1
    r3 = r2
    goto L3
L2:
    r4 = y ^ 1
    r5 = r4
    r6 = CPyLong_AsInt64(r5)
    r3 = r6
    keep_alive y
L3:
    r7 = x + r3
    x = r7
    return x

[case testLowLevelIntMixedCompare1]
from mypy_extensions import i64
def f(x: int, y: i64) -> bool:
    return x == y
[out]
def f(x, y):
    x :: int
    y :: int64
    r0 :: native_int
    r1 :: bit
    r2, r3 :: int64
    r4 :: ptr
    r5 :: c_ptr
    r6 :: int64
    r7 :: bit
L0:
    r0 = x & 1
    r1 = r0 == 0
    if r1 goto L1 else goto L2 :: bool
L1:
    r2 = x >> 1
    r3 = r2
    goto L3
L2:
    r4 = x ^ 1
    r5 = r4
    r6 = CPyLong_AsInt64(r5)
    r3 = r6
    keep_alive x
L3:
    r7 = r3 == y
    return r7

[case testLowLevelIntMixedCompare2]
from mypy_extensions import i64
def f(x: i64, y: int) -> bool:
    return x == y
[out]
def f(x, y):
    x :: int64
    y :: int
    r0 :: native_int
    r1 :: bit
    r2, r3 :: int64
    r4 :: ptr
    r5 :: c_ptr
    r6 :: int64
    r7 :: bit
L0:
    r0 = y & 1
    r1 = r0 == 0
    if r1 goto L1 else goto L2 :: bool
L1:
    r2 = y >> 1
    r3 = r2
    goto L3
L2:
    r4 = y ^ 1
    r5 = r4
    r6 = CPyLong_AsInt64(r5)
    r3 = r6
    keep_alive y
L3:
    r7 = x == r3
    return r7
